- function Vue(options) {this._init(options)}
- initMixin(Vue)
  - Vue.prototype._init
    - initLifecycle(vm) 忽略
    - initEvents(vm) 忽略
    - initRender(vm) 忽略
    - callHook(vm, 'beforeCreate') beforeCreate 事件
    - initInjections(vm) 初始化 injections
    - initState(vm) 初始化 data
      - initProps 初始化 props，根组件没有
      - initMethods
      - initData 没有 data 则 observe({}) 赋值给 data、
        - proxy 逆序遍历 data，data -> _data
        - 如果有相同的 methods ，则会发出 methods 已经在 data 中定义 警告
        - 如果有相同的 props，则会发出 data 已经在 props 上定义
        - 否则，则挂载到 _data 中
        - observe(data)
          - new Observer()
            - constructor
            - isArray 
              - 改变原有数组的 __proto__ -> arrayMethods
                - arrayMethods 中重写了 push pop shift unshift splice sort reverse
                - 调用这些方法，会去调用对象的 ob.dep.notify() 通知更新
              - this.observeArray(value)
                - 循环遍历每个元素，调用 observe(value[i])
            - else -> defineReactive(value, key) 遍历对象的每个key，生成响应式对象
              - observe(child)
              - get: reactiveGetter
                - Dep.target
                - dep.depend()
              - set: reactiveSetter
                - getter.call(obj) hasChange(value, newVal)
                - dep.notify()
                  - watcher.update()
                    - scheduler queueWatcher(this)
                      - watcher.run() 调用更新
      - initComputed 计算属性实现原理
        - watchers = (vm._computedWatchers = Object.create(null)) 把监听加入到 vm 中
        - getter = isFunction(userDef) ? userDef : userDef.get
        - watchers[key] = new Watcher(vm, getter, noop, {lazy: true}) 创建 watcher 对象，并且懒加载
        - defineComputed(vm, key, userDef) 循环遍历 key 调用 
          - sharedPropertyDefinition 设置对应的 getter 和 setter
            - getter
              - watcher = this._computedWatchers[key]
              - watcher.dirty 
                - watcher.evaluate() 表明值有变动，需要重新获取值
                  - this.value = this.get()
                  - this.dirty = false
              - Dep.target && watcher.depend() 添加依赖
              - return watcher.value 返回缓存的值
            - setter = userDef.set || noop
          - Object.defineProperty(vm, key, sharedPropertyDefinition)
      - initWatch
        - isArray
          - 遍历每个节点 调用 createWatcher(vm, key, handler[i])
        - else
          - createWatcher(vm, key, handler)
            - return vm.$watch(key, handler, options)
    - initProvide(vm) 初始化 provide
    - callHook(vm, 'created)
    - if vm.$options.el -> vm.$mount(vm.$options.el)
- stateMixin(Vue)
  - Object.defineProperty(Vue.prototype, '$data', dataDef)
  - Object.defineProperty(Vue.prototype, '$props', propsDef) 
  - Vue.prototype.$set = set
  - Vue.prototype.$delete = del
  - Vue.prototype.$watch = function (expOrFn, cb, options) {}
    - if isPlainObject(cb)
      - return createWatcher(vm, expOrFn, cb, options)
    - watcher = new Watcher(vm, expOrFn, cb, options)
    - options.immediate === true
      - handler 执行该方法
    - return unwatchFn()
      - watcher.teardown()- eventsMixin(Vue)
  - Vue.prototype.$on = function () {}
  - Vue.prototype.$once = function () {}
  - Vue.prototype.$off = function () {}
  - Vue.prototype.$emit = function () {}
- lifecycleMixin(Vue)

[//]: # (TODO _update patch 函数在这里)
  - Vue.prototype._update = function () {}
    - vm.__patch__ = patch
      - patch = createPatchFunction (vdom/patch.ts)
  - Vue.prototype.$forceUpdate = function () {}
  - Vue.prototype.$destroy = function () {}
- renderMixin(Vue)
  - Vue.prototype._o = markOnce
  - Vue.prototype._n = toNumber
  - Vue.prototype._s = toString
  - Vue.prototype._l = renderList
  - Vue.prototype._t = renderSlot
  - Vue.prototype._q = looseEqual
  - Vue.prototype._i = looseIndexOf
  - Vue.prototype._m = renderStatic
  - Vue.prototype._f = resolveFilter
  - Vue.prototype._k = checkKeyCodes
  - Vue.prototype._b = bindObjectProps
  - Vue.prototype._v = createTextVNode
  - Vue.prototype._e = createEmptyVNode
  - Vue.prototype._u = resolveScopedSlots
  - Vue.prototype._g = bindObjectListeners
  - Vue.prototype._d = bindDynamicKeys
  - Vue.prototype._p = prependModifier
  - Vue.prototype.$nextTick = nextTick
  - Vue.prototype._render = function() {}
- Vue.prototype.$mount = return mountComponent(this, el)
  - createEmptyVNode
  - callHook(vm, 'beforeMount)

[//]: # (TODO _update patch 函数在这里)
  - updateComponent = () => {vm._update(vm._render(), hydrating)} 生成 vnode， patch vnode，第一次则生成 vnode然后生成真实 dom ,可以理解为 render 函数
  - new Watcher(vm, updateComponent, noop, watcherOptions, true)
    - this.getter = expOrFn -> updateComponent render 函数
    - this.get()
      - pushTarget(this) Dep.target = Wather
      - this.getter.call(vm, vm) 执行 render 函数，收集依赖
      - popTarget()
  - callHook(vm, 'mounted)

- nextTick
  - Promise.resolve().then()
    - timerFunc = () => {p.then(flushCallbacks)}
    - is(isIOS) setTimeout(noop)
  - MutationObserve
    - const observer = new MutationObserve(flushCallbacks)
    - const textNode = document.createTextNode(String(counter))
    - observer.observe(textNode, { characterData: true})
    - timerFunc = () => {counter = (counter + 1) % 2; textNode.data = String(counter)}
  - setImmediate
    - timerFunc = () => {setImmediate(flushCallbacks)}
  - setTimeout
    - timerFunc = () => {setTimeout(flushCallbacks, 0)}

- queueWatcher
  - id = watcher.id
  - has[id] return 同样的 watcher 不会重复渲染
  - queue.push(watcher)
  - nextTick(flushSchedulerQueue)
    - queue.sort()
    - for queue
      - watcher = queue[i]
      - watcher.before beforeUpdate 事件 或者 beforeUpdate 事件
      - watcher.run()
    - callActivatedHooks(activatedQueue) 调用 activated 回调
    - callUpdatedHooks(updatedQueue) 调用 updated 回调